<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>client6</title>
    <script src="./vue@3.2.36.global.prod.js"></script>
    <script src="./peerjs.1.5.2.min.js"></script>
    <!-- <script src="./qrcode.js"></script> -->
    <style>
        .own, .another {
            font-size: 2rem;
        }
    </style>
</head>
<body>
<div id="app">
<!-- 
http://127.0.0.1:3000/client6.html?match_id=4&send_id=5&receive_id=7&sender_or_receiver=sender

⭕️
paramsを取得(match_id, send_id, receive_id, sender_or_receiver): mounted get_param() getのパラメーターからthis.match_id this.send_id this.receive_id this.sender_or_receiverをセット

❌
fetch_get_peer_id_from_matches_as_sender_or_as_receiver() /get_peer_id_from_matches_as_sender_or_as_receiver
    // peer_idを取得するエンドポイント // sender_or_receiverがsenderならreceiver_peer_idを取得,receiverならsender_peer_idを取得
fetch_read_matches_any() /read_matches_any
    fetch_read_matches("read_matches") /read_matches
    fetch_read_matches("read_waiting_matches") /read_waiting_matches
        // matchesからqueryで(match_id, send_id, receive_id, sender_or_receiver)when_to_sendを取得 => 一つの関数にまとめる
fetch_update_when_to_send() /update_when_to_send => (match_id, receive_or_waiting, peer_id_when_get_open, send_id, receive_id, sender_or_receiver)
    // matchesからqueryで(match_id, send_id, receive_id, sender_or_receiver)when_to_sendの更新(match=>receive=>waiting) => 一つの関数にまとめる
fetch_check_peer_id_or_change_it() /check_peer_id_or_change_it
    // sender_peer_idとreceiver_peer_idが必要(sender_peer_id,receiver_peer_idどちらかが欠けていることがある)
    // sender_peer_idとreceiver_peer_idが一致しているか確認し、一致していなければ更新する
-->

{{ login_id_name }}
{{ sender_peer_id }}
{{ receiver_peer_id }}
{{ waiting_matched }}

    ページをリフレッシュした際にpeer id Aが変わるため、
    sender_peer_idもしくはreceiver_peer_idを更新
    バックグラウンドでpeer idがclientとserverに相違がないか確認し、
    相違があれば更新するようにコードを追加する

    match_id: {{ match_id }}
    send_id: {{ send_id }}
    receive_id: {{ receive_id }}
    sender_or_receiver: {{ sender_or_receiver }}
    ERROR_MESSAGE: {{ ERROR_MESSAGE }}
    sample: {{ sample }}
    peer_id_when_get_open: {{ peer_id_when_get_open }}
    my_user_id: {{ my_user_id }}
    receive_matched: {{ receive_matched }}
    matched: {{ matched }}
    other_side_data_link: {{ other_side_data_link }}
    endpoint: {{ endpoint }}
    <!-- button fetch_hello -->
    <button @click="fetch_hello()">fetch_hello</button>



    <div id="qrcode"></div>
    <a href="" id="url_with_peer_id">url_with_peer_id</a>
    <p>サーバーサイドのコードは https://glitch.com/edit/#!/cypress-serious-bird?path=server.js</p>
    <p>参考にしたコードは https://glitch.com/~peerjs-video</p>
    <button @click="send_text_fn()">send_text_fn param sample</button>
    <button @click="send_text_fn('FOOOOOOOOOOOO')">send_text_fn my text</button>
    <div class="random_message"></div>
    <p>このURL(https://taroyanaka.github.io/peerjs_webrtc/client3.html)2枚のタブで別々に開く。片方に表示されたpeer id Aの英数文字列を、もう片方のタブのPeer ID BのinputにコピペしてConnect Bをクリック</p>
    peer id A<input class="result" type="text">
    <input id="connect-to-peer" type="text" placeholder="Peer ID B">
</div>
</body>
<script>
let global_conn = null;
let global_peerId = null;
let hoge = null;
let fuga = null;
let url_with_peer_id = window.location.href;

const app = Vue.createApp({
data() {
return {
    login_id_name: {id: null, name: null},
sender_peer_id: null,
receiver_peer_id: null,

    waiting_matched: null,

    peer_id_when_get_open: '',
    ERROR_MESSAGE: '',
    sample: null,
    match_id: 0,
    send_id: 0,
    receive_id: 0,
    sender_or_receiver: '', // 'sender' or 'receiver'

    my_user_id: null,
    receive_matched: null,
    matched: null,
    other_side_data_link: '',
    endpoint: 'http://localhost:8000',
    // endpoint: 'https://cotton-concrete-catsup.glitch.me',

}
},
watch: {
// any_array: {
//         handler(new_val, old_val) {
//     },
//     deep: true
// },
},
mounted() {
    this.get_param();
},
beforeUpdated() {},
updated() {},
methods: {
async fetch_check_peer_id_or_change_it(){
    try {
        const res = await fetch(this.endpoint + '/check_peer_id_or_change_it', {method: 'POST',headers: {'Content-Type': 'application/json',},
                body: JSON.stringify({
                    match_id: this.match_id,
                    sender_or_receiver: this.sender_or_receiver,
                    peer_id: this.peer_id_when_get_open,
                }),
            });
        const data = await res.json(); console.log(data);
        this.sender_peer_id = data.message.sender_peer_id;
        this.receiver_peer_id = data.message.receiver_peer_id;
        if(this.sender_or_receiver === 'sender'){
            document.querySelector('.result').value = this.sender_peer_id;
            document.querySelector('#connect-to-peer').value = this.receiver_peer_id;
        }
        if(this.sender_or_receiver === 'receiver'){
            document.querySelector('.result').value = this.receiver_peer_id;
            document.querySelector('#connect-to-peer').value = this.sender_peer_id;
        }
        this.ERROR_MESSAGE = "";
    } catch (error) {
        this.ERROR_MESSAGE = error.message;
    }
},
async fetch_get_peer_id_from_matches_as_sender_or_as_receiver(){
try {
    const res = await fetch(this.endpoint + '/get_peer_id_from_matches_as_sender_or_as_receiver', {method: 'POST',headers: {'Content-Type': 'application/json',},
            body: JSON.stringify({
                match_id: this.match_id,
                sender_or_receiver: this.sender_or_receiver,
            }),
        });
    const data = await res.json(); console.log(data);
    if(data.message){
        if(this.sender_or_receiver === 'sender'){
            document.querySelector('.result').value = data.message.peer_id_a;
            document.querySelector('#connect-to-peer').value = data.message.peer_id_b;
        }
        if(this.sender_or_receiver === 'receiver'){
            document.querySelector('.result').value = data.message.peer_id_b;
            document.querySelector('#connect-to-peer').value = data.message.peer_id_a;
        }
    }
    this.ERROR_MESSAGE = "";
} catch (error) {
    this.ERROR_MESSAGE = error.message;
}
},

// async fetch_update_when_to_send_change(To_Any="waiting", id=null){ // change to receive or waiting
async fetch_update_when_to_send(To_Any="waiting", id=null){ // change to receive or waiting
try {
    // To_Anyが"receive"でも"waiting"でもどちらでもない場合はエラースロー
    if(To_Any !== "receive" && To_Any !== "waiting"){
        throw new Error('To_Any is not "receive" or "waiting"');
    }

    if(To_Any === "receive"){
        // const res = await fetch(this.endpoint + '/update_when_to_send_receive', {method: 'POST',headers: {'Content-Type': 'application/json',},
        const res = await fetch(this.endpoint + '/update_when_to_send', {method: 'POST',headers: {'Content-Type': 'application/json',},
                body: JSON.stringify({
                    match_id: Match_Id,
                    receive_or_waiting: 'receive',
                }),
            });
        const data = await res.json(); console.log(data);
        this.receive_matched = data.message;
        this.ERROR_MESSAGE = "";
    }
    if(To_Any === "waiting"){
        this.peer_id_when_get_open = set_update_when_to_send_waiting(id);
        // const res = await fetch(this.endpoint + '/update_when_to_send_waiting', {method: 'POST',headers: {'Content-Type': 'application/json',},
        const res = await fetch(this.endpoint + '/update_when_to_send', {method: 'POST',headers: {'Content-Type': 'application/json',},
                body: JSON.stringify({
                    receive_or_waiting: 'waiting',
                    peer_id_when_get_open: this.peer_id_when_get_open,
                    match_id: this.match_id,
                    send_id: this.send_id,
                    receive_id: this.receive_id,
                    sender_or_receiver: this.sender_or_receiver,
                }),
            });
        const data = await res.json(); console.log(data);
        this.ERROR_MESSAGE = "";
    }
} catch (error) {
    this.ERROR_MESSAGE = error.message;
}
},
async fetch_read_matches(Req_Type="read_matches"){
    let data = null;
        if(Req_Type === "read_waiting_matches"){
            const res = await fetch(this.endpoint + '/read_waiting_matches', {method: 'POST',headers: {'Content-Type': 'application/json',},
                    body: JSON.stringify({user_id: this.login_id_name.id}),
                });
            data = await res.json(); console.log(data);
            this.waiting_matched = data.message;
        }
        if(Req_Type === "read_matches"){
            const response = await fetch(this.endpoint + '/read_matches');
            data = await response.json();
        }
    if(data.message){
        console.log(data);
        this.matched = data.message;
        this.sender_or_receiver = (new URL(window.location.href).searchParams.get('sender_or_receiver'));
        this.match_id = this.matched[0].id;
        if(this.sender_or_receiver === 'sender'){
            this.login_id_name.id = this.matched[0].send_id;
        }
        if(this.sender_or_receiver === 'receiver'){
            this.login_id_name.id = this.matched[0].receive_id;
        }
    }
    return data;
},
async fetch_read_matches_any(All_Or_Waiting_Receive="all"){
try {
    const res = await fetch(this.endpoint + '/read_matches_any', {method: 'POST',headers: {'Content-Type': 'application/json',},
            body: JSON.stringify({
                all_or_waiting_receive: All_Or_Waiting_Receive,
                user_id: this.login_id_name.id,
                match_id: this.match_id
            }),
        });
    const data = await res.json(); console.log(data);
    this.sample = data.message;
    this.sender_or_receiver = data.message[0].sender_or_receiver;
    this.match_id = data.message[0].id;
    // this.login_id_name.id = data.message[0].send_id;
    this.login_id_name.id = this.sender_or_receiver === 'sender' ? data.message[0].send_id : data.message[0].receive_id;
    this.login_id_name.id = this.sender_or_receiver === 'receiver' ? data.message[0].receive_id : data.message[0].send_id;
    this.ERROR_MESSAGE = "";
} catch (error) {
    this.ERROR_MESSAGE = error.message;
}
},



send_text_fn(Text="sample_text"){
    console.log("send_text_fn");
    send_text(Text);
},
to_ary(from){
    return JSON.parse(JSON.stringify(from));
},
parse_url(){
    const url = new URL(window.location.href);
    const other_side_data_str = url.searchParams.get('other_side_data_str');
    const own_side_data_str = url.searchParams.get('own_side_data_str');
    if (other_side_data_str){
        console.log("other_side_data_str", other_side_data_str);
        console.log(JSON.parse(other_side_data_str));
    }
    if (own_side_data_str){
        console.log("own_side_data_str", own_side_data_str);
        console.log(JSON.parse(own_side_data_str));
    }
},
get_param(){
    try {
            // get_paramで以下のようなパラメータを取得する
    // this.match_id,this.send_id,this.receive_id,に取得したparametersを代入後。サーバーのmatchesをfetchする
// 'sender' 'http://localhost:8000/client6.html?match_id=1&send_id=5&receive_id=7&sender_or_receiver=sender'
// 'receiver' 'http://localhost:8000/client6.html?match_id=1&send_id=5&receive_id=7&sender_or_receiver=receiver'
    const url = new URL(window.location.href);
    this.match_id = url.searchParams.get('match_id') ? url.searchParams.get('match_id') : (() => {throw new Error('match_id is not found')})();
    this.send_id = url.searchParams.get('send_id') ? url.searchParams.get('send_id') : (() => {throw new Error('send_id is not found')})();
    this.receive_id = url.searchParams.get('receive_id') ? url.searchParams.get('receive_id') : (() => {throw new Error('receive_id is not found')})();
    this.sender_or_receiver = url.searchParams.get('sender_or_receiver') ? url.searchParams.get('sender_or_receiver') : (() => {throw new Error('sender_or_receiver is not found')})();
    // this.match_id, this.send_id, this.receive_idをNumber()にする
    this.match_id = Number(this.match_id), this.send_id = Number(this.send_id), this.receive_id = Number(this.receive_id);
console.log("this.match_id", this.match_id, "this.send_id", this.send_id, "this.receive_id", this.receive_id, "this.sender_or_receiver", this.sender_or_receiver);
    // => 片方がchatにログイン(matchをwaitingに,peer_idをmatchesに挿入) => 対向にwaitingであることが表示 =>

    } catch (error) {
        console.log(error);
    }
},


}}).mount('#app');
const set_url_with_peer_id = () => {
    document.getElementById('url_with_peer_id').href =
        url_with_peer_id
         + '&peer_id_b=' + document.querySelector('.result').value;
}
const get_peer_id = () => {
    const url = new URL(window.location.href);
    const peer_id = url.searchParams.get('peer_id_b');
    if (peer_id){
        console.log("get id", peer_id);
        document.querySelector('#connect-to-peer').value = peer_id;
        connect_to_peer_for_call();
    }
}
document.addEventListener('DOMContentLoaded', get_peer_id);
let messagesEl = document.querySelector('.messages');
let videoEl = document.querySelector('.remote-video');
let renderVideo = (stream) => {
    document.querySelector('video').srcObject = stream;
};
let peer = new Peer({
    host: 'cypress-serious-bird.glitch.me',
    secure: true,
    path: '/peerjs/myapp'
});
peer.on('error', (error) => {
    console.error(error);
});
peer.on('call', (call) => {
    async function getMedia() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});
            call.on('stream', renderVideo);
        } catch (err) {
            console.error('Failed to get local stream', err);
        }
    }
    getMedia();
});
let connect_to_peer_for_call = async () => {
    try {
    let peerId = document.querySelector('#connect-to-peer').value;
    const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});
    let call = peer.call(peerId, stream);
    call.on('stream', renderVideo);
} catch (err) {
}
};
let my_side_global_conn = null;
let text_array = [];
peer.on('open', (id) => {
    document.querySelector('.result').value = id;
    my_side_global_conn = id;
    set_url_with_peer_id();
    app.fetch_update_when_to_send_change("waiting", id);
});



            console.log("new another_peer_id", data.another_peer_id);
            document.querySelector('#connect-to-peer').value = data.another_peer_id;
            global_peerId = data.another_peer_id;
        }
        if(data.random_message){
            console.log("random_message", data.random_message);
            text_array.push(data.random_message);
            document.querySelector('.random_message').textContent = text_array.join('\n');
        }
    });
function sendMessage(message) {conn.send(message)}
sendMessage('Hello, peer!');
});


let peer_id = null;


let first_send = true;
function send_text(Text="sample_text"){
    console.log("send_text");

    if(document.querySelector('#connect-to-peer').value === ''){
        document.querySelector('#connect-to-peer').value = (new URL(window.location.href).searchParams.get('peer_id_b'));
    }
    if(new URL(window.location.href).searchParams.get('peer_id_b')){
        peerId = new URL(window.location.href).searchParams.get('peer_id_b');
    }else{
        peerId = global_peerId;
    }
    if (!peerId) {
        console.error('Peer ID is not specified.');
        return;
    }

    let conn2 = peer.connect(peerId);

    conn2.on('open', function() {
        try {
            if(my_side_global_conn && first_send === true){
                conn2.send({another_peer_id: my_side_global_conn});
                first_send = false;
            }
            conn2.send({random_message: Text});
        } catch (err) {
            console.error('Failed to send message:', err);
        }
    });

    conn2.on('error', function(err) {
        console.error('Connection error:', err);
    });
}
</script>    
</html>
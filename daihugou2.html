<!-- check_passを修正する(humanがpassした後に処理されない) -->
<!DOCTYPE html>
<html>
<head>
    <title>大富豪</title>
    <script src="./vue@3.2.36.global.prod.js"></script>
</head>
<style>
    h1, h2 {
        font-size: 0.5rem;
    }
</style>
<body>
    <div id="app">
        <button @click="ai_play_card(this.current_player_index_num)">play_last</button>
        <!-- testing switch button -->
        <button @click="testing = !testing">testing button</button>
        {{ testing }}
        <button @click="revolution = !revolution">revolution button</button>
        <h2>revolution: {{ revolution }}</h2>
        passed_players_index: {{ passed_players_index }}
        winner_player_ary: {{ winner_player_ary }}
        <!-- <button @click="human_pass(0)">pass</button> -->
        {{this.current_player_index_num}}

        <h2 v-for="(player, player_idx) in player_name">{{ player }}: {{ player_card[player_idx].length }}</h2>
        <button @click="startGame">ゲーム開始</button>
        <div v-for="card in field_card">
            <h2>{{ card }}</h2>
        </div>
        <div v-for="(player, player_idx) in player_name">
            <h2>{{ player }}</h2>
            <div v-for="card in player_card[player_idx]">
                <h2>
                    {{ card }}
                    <!-- <button @click="playCard(player_idx, card.id)">use</button> -->
                    <!-- <button @click="all_player_play(player_idx, card.id)">all_player_play</button> -->
                    <!-- ifでhumanの時だけボタン表示 -->
                    <span v-if="player_idx === 0" @click="human_play_card(player_idx, card.id)">
                    <button @click="human_player_play(player_idx, card.id)">human_player_play</button>
                    </span>
                </h2>
            </div>
        </div>
    </div>
    <script>
        const compareBy = operator => {
            switch (operator) {
                case '<': return (a, b) => a < b;
                case '>': return (a, b) => a > b;
                default: throw new Error('Invalid operator');
            }
        };

const app = Vue.createApp({
data() {
    return {
        winner_player_ary: [],
        passed_players_index: [],
        played_player_index: [],
        player_name: [],
        player_card: [],
        field_card: [],
        deck: [],
        revolution: false,
        last_played_player_idx: null,

        testing: false,
    }
},
mounted() {
    this.startGame();
},
methods: {
    getCardIdx(cardIdx) {
        return this.current_card_idx = cardIdx;
    },
    startGame() {
        this.deck = this.shuffle(this.createDeck());
        this.dealCards();
    },
    createDeck() {
        const suits = ['Spades', 'Hearts', 'Diamonds', 'Clubs'];
        const ranks = Array.from({length: 13}, (_, i) => i + 1);
        return suits.flatMap(suit => ranks.map((rank, idx) => ({ rank, suit })));
    },
    shuffle(array) {
        return array.sort(() => Math.random() - 0.5);
    },
    dealCards() {
        this.player_name = ['human1', 'ai1', 'ai2', 'ai3', 'ai4', 'ai5', 'ai6', 'ai7', 'ai8', 'ai9'];
        const eachPlayerCardNumAry = [...Array(this.player_name.length).keys()].map(idx => Math.floor(this.deck.length / this.player_name.length) + (idx < this.deck.length % this.player_name.length ? 1 : 0));
        while(this.player_name.length){
            const player = this.player_name.shift();
            this.player_card.push(this.deck.splice(0, eachPlayerCardNumAry.shift()).map((card, idx) => ({ ...card, id: player+"_"+idx.toString() })));
            this.player_name.push(player);
            if(this.deck.length === 0){break;}
        }
        this.player_card = this.player_card.map(cards => cards.sort((a, b) => a.rank - b.rank));
    },
    can_and_exe(playerIdx, playerCard, card) {
        console.log("can_and_exe");
        const playerName = this.player_name[playerIdx];
        const is_can = (playerIdx, playerCard, card, playerName) => {
            if (this.can_play_card(card.rank)) {
                this.field_card.push(card);
                this.player_card[playerIdx] = playerCard.filter(c => c.id !== card.id);
                if (this.player_card[playerIdx].length === 0) {
                    this.winner_player_ary.push(playerIdx);
                    console.log(`${playerName}の勝利`);
                }
                this.passed_players_index = [];
                this.manage_turn(false, playerIdx);
            }
        }
        is_can(playerIdx, playerCard, card, playerName);
    },
    human_play_card(playerIdx, cardId, pass=false) {
        const playerCard = this.player_card[playerIdx];
        if (this.winner_player_ary.includes(playerIdx)) {
            return;
        }
        const card = playerCard.find(c => c.id === cardId);
        this.can_and_exe(playerIdx, playerCard, playerCard.find(c => c.id === cardId));
        if (this.is_field_card_nothing === false && !this.can_play_card(card.rank)) {
            console.log("fieldに出せないカードを出そうとした");
            throw new Error("fieldに出せないカードを出そうとした");
        }
    },
    human_pass() {
        this.manage_turn(true, 0, 0);
        this.check_pass();
    },
    human_player_play(playerIdx, cardId, pass=false) {
        if(this.field_card.length !== 0 && this.field_card[this.field_card.length - 1].rank > this.player_card[playerIdx].find(c => c.id === cardId).rank ) {
            console.log("rankが低いのでfield_cardに出せるカードでは無い");
            return;
        }

        this.human_play_card(playerIdx, cardId, pass);
        this.manage_turn(pass, playerIdx);
        this.ai_player_play();
    },
    ai_player_play(start_idx) {
        // start_idxから始まる配列を作成
        start_idx = start_idx || 5;
        const start_idx_ary = this.player_name.slice(start_idx).map((_, idx) => idx + start_idx);
        console.log("START_IDX_ARY", start_idx_ary);

        // start_idx_aryの先頭から順にai_play_cardを実行
        start_idx_ary.forEach(i => {
            this.ai_play_card(i, this.player_name[i]);
        })
        if(start_idx_ary.length !== 0){
            return;
        }
        // 全てのstart_idx_aryを実行した場合はreturn



        // human以外のwinner_player_aryに含まれていないaiプレイヤー
        for (let i = 1; i < this.player_name.length; i++) {
            // winner以外
            if (!this.winner_player_ary.includes(i)) {
                this.ai_play_card(i, this.player_name[i]);
            }
        }
    },
    // passが特定のプレイヤー以外一巡したか確認する関数
    check_pass() {
        // pass確認関数:check_fnはwinner_player_aryに含まれていないlast_played_player_idx以外のプレイヤーが全員passしたらtrueを返す関数
        const all_player_passed_check_fn = () => {
            console.log("this.passed_players_index.length, this.player_name.length");
            console.log(this.passed_players_index.length, this.player_name.length);
            if (this.passed_players_index.length === this.player_name.length - 1) {
            // if (this.passed_players_index.length === this.player_name.length - this.winner_player_ary.length - 1) {
                return true;
            }
            return false;
        }
        if (all_player_passed_check_fn() === true) {
            console.log("ALL PLAYER PASSED");
            this.field_card = [];
            this.passed_players_index = [];
            this.current_player_index_num = this.last_played_player_idx;
            if(this.last_played_player_idx !== 0) {
                // this.ai_play_card(this.last_played_player_idx);
                this.ai_player_play(this.last_played_player_idx);
            }
        }
        if (all_player_passed_check_fn() === false) {
            console.log("all_player_passed_check_fn() === false");
            // 残りのpassしていないplayerにターンを渡して、残り全員passならfield_cardとpassed_players_indexを初期化して、fieldで最後にカードを出したplayerにターンを渡す
            const remaining_player_idx = this.player_name.filter((_, idx) => !this.passed_players_index.includes(idx));
            // remaining_player_idxを配列に変換
            const remaining_player_idx_ary = this.player_name_to_index_ary(remaining_player_idx);
            console.log(remaining_player_idx_ary);
            console.log(this.last_played_player_idx);
            // remaining_player_idx_aryが空でない場合remaining_player_idx_aryの先頭のプレイヤーにターンを渡す
            if (remaining_player_idx_ary.length !== 0) {
                this.current_player_index_num = remaining_player_idx_ary[0];
            }


        }
    },
    can_play_card(rank) {
        if (this.is_field_card_nothing() || compareBy(this.revolution === true ? ">" : "<" )(this.field_card[this.field_card.length - 1].rank, rank)) {
            return true;
        }
        return false;
    },
    ai_play_card(AI_PLAYER_IDX=1) {
        // AI_PLAYER_IDXが0の時はhuman_pass(0)を実行して終了
        if (AI_PLAYER_IDX === 0) {
            this.human_pass();
            return;
        }

        console.log("ai_play_card", AI_PLAYER_IDX);
        if (this.winner_player_ary.includes(AI_PLAYER_IDX)) {return};
        const playerCard = this.player_card[AI_PLAYER_IDX];
        // field_cardが空の場合はランダムにカードを出す
        // field_cardに出せるカードがある場合はその中からランダムにカードを出す
        const card = this.is_field_card_nothing() ? playerCard[Math.floor(Math.random() * playerCard.length)] : playerCard.filter(c => this.can_play_card(c.rank))[Math.floor(Math.random() * playerCard.filter(c => this.can_play_card(c.rank)).length)];
        this.testing === true ? console.log("this.is_field_card_nothing()", this.is_field_card_nothing()) : null;
        // cardがundefinedの場合はpassする
        const pass = card === undefined;


        this.testing === true ? console.log("playerCard.filter(c => this.can_play_card(c.rank)).length === 0", playerCard.filter(c => this.can_play_card(c.rank)).length === 0) : null;
        this.testing === true ? console.log("card", card) : null;
        this.testing === true ? console.log("pass", pass) : null;
        // pass ? (this.check_pass(), this.passed_players_index.push(AI_PLAYER_IDX)) : this.can_and_exe(AI_PLAYER_IDX, playerCard, card);
        pass ? (this.manage_turn(true, 0, AI_PLAYER_IDX), this.check_pass()) : this.can_and_exe(AI_PLAYER_IDX, playerCard, card);
    },
    is_field_card_nothing() {
        return this.field_card.length === 0;
    },
    // turnを管理する関数(passed_players_indexとplayed_player_indexとwinner_player_aryによってcurrent_player_index_numを更新する)
    manage_turn(pass=false, played_player=0, passed_player=0) {
        if(pass === true) {
            this.passed_players_index.push(passed_player);
        }
        if(pass == false) {
            this.last_played_player_idx = played_player;
            this.played_player_index.push(played_player);
        }
    },
    // player_nameをindexの数字の配列に変換する関数
    player_name_to_index_ary(player_name_ary){
        // player_name_aryは['human1', 'ai1', 'ai2', 'ai3', 'ai4', 'ai5', 'ai6', 'ai7', 'ai9']のような配列
        return player_name_ary.map(player_name => this.player_name.indexOf(player_name));
    },

    to_ary(ary_like) {
        return JSON.parse(JSON.stringify(ary_like));
    }
}
}).mount('#app');
    </script>
</body>
</html>
